use std::collections::{hash_map::Entry, HashMap};

use crate::{
    base::BaseNames,
    modules::{Member, ModuleTree},
    names::{Name, Names},
};
use aiahr_core::{
    cst::{self, Field, IdField, ProductRow, Separated, SumRow},
    diagnostic::{nameres::NameResolutionError, DiagnosticSink},
    id::{IdGen, Ids, ItemId, ModuleId, VarId},
    if_none::IfNone,
    memory::handle::RefHandle,
    nst,
    span::{Span, SpanOf, Spanned},
};
use bumpalo::Bump;

// Allocates the items in `iter` on the given arena, but only if they are all `Some(..)`.
fn alloc_all<'a, T, I>(arena: &'a Bump, iter: I) -> Option<&'a [T]>
where
    I: Iterator<Item = Option<T>>,
{
    iter.collect::<Option<Vec<T>>>()
        .map(|v| arena.alloc_slice_fill_iter(v.into_iter()) as &[T])
}

// Tries to map the given function over the elements of `separated`, returning all errors.
fn resolve_separated<'a, A, B, F>(
    arena: &'a Bump,
    separated: &Separated<'_, A>,
    f: F,
) -> Option<Separated<'a, B>>
where
    F: FnMut(&A) -> Option<B>,
{
    let mut f = f;
    let first = f(&separated.first);
    let elems = alloc_all(
        arena,
        separated.elems.iter().map(|(c, a)| Some((*c, f(a)?))),
    );
    Some(Separated {
        first: first?,
        elems: elems?,
        comma: separated.comma,
    })
}

// Tries to map the given function over the target.
fn resolve_id_field<'s, A, B, F>(field: &IdField<'s, A>, f: F) -> Option<IdField<'s, B>>
where
    F: FnOnce(&A) -> Option<B>,
{
    Some(IdField {
        label: field.label,
        sep: field.sep,
        target: f(&field.target)?,
    })
}

// Tries to map the given function over the targets of `prod`.
fn resolve_product_row<'a, 's, A, B, F>(
    arena: &'a Bump,
    prod: &ProductRow<'_, 's, A>,
    f: F,
) -> Option<ProductRow<'a, 's, B>>
where
    F: FnMut(&A) -> Option<B>,
{
    let mut f = f;
    let fields = if let Some(cs) = &prod.fields {
        Some(resolve_separated(arena, &cs, |field| {
            resolve_id_field(field, &mut f)
        })?)
    } else {
        None
    };
    Some(ProductRow {
        lbrace: prod.lbrace,
        fields,
        rbrace: prod.rbrace,
    })
}

// Tries to map the given function over the target of `sum`.
fn resolve_sum_row<'s, A, B, F>(sum: &SumRow<'s, A>, f: F) -> Option<SumRow<'s, B>>
where
    F: FnOnce(&A) -> Option<B>,
{
    Some(SumRow {
        langle: sum.langle,
        field: resolve_id_field(&sum.field, f)?,
        rangle: sum.rangle,
    })
}

// The possible meanings of a `DotAccess` term.
#[derive(Debug)]
enum DotResolution<'a, 's> {
    Module(ModuleId),
    Item(ModuleId, ItemId),
    FieldAccess {
        base: &'a nst::Term<'a, 's>,
        dot: Span,
        field: SpanOf<RefHandle<'s, str>>,
    },
}

impl<'a, 's> DotResolution<'a, 's> {
    fn from_member(parent: ModuleId, memb: Member) -> DotResolution<'a, 's> {
        match memb {
            Member::Module(m) => DotResolution::Module(m),
            Member::Item(i) => DotResolution::Item(parent, i),
        }
    }
}

/// Data generated by resolving a module.
#[derive(Debug)]
pub struct ModuleResolution<'a, 's> {
    pub items: Box<Ids<ItemId, SpanOf<RefHandle<'s, str>>>>,
    pub vars: Box<Ids<VarId, SpanOf<RefHandle<'s, str>>>>,
    pub item_names: HashMap<RefHandle<'s, str>, ItemId>,
    pub resolved_items: &'a [Option<nst::Item<'a, 's>>],
}

/// Context for resolving names in a module.
#[derive(Debug)]
pub struct Resolver<'a, 'e, 's, E> {
    arena: &'a Bump,
    vars: IdGen<VarId, SpanOf<RefHandle<'s, str>>>,
    errors: &'e mut E,
}

impl<'a, 'e, 's, E> Resolver<'a, 'e, 's, E> {
    /// Constructs a new `Resolver` that allocates into the given arena and reports errors to the
    /// given sink.
    pub fn new(arena: &'a Bump, errors: &'e mut E) -> Resolver<'a, 'e, 's, E> {
        Resolver {
            arena,
            vars: IdGen::new(),
            errors,
        }
    }

    /// Consumes the `Resolver` and returns its variable table.
    pub fn into_vars(self) -> Box<Ids<VarId, SpanOf<RefHandle<'s, str>>>> {
        self.vars.into_boxed_ids()
    }
}

impl<'a, 'e, 's, E> Resolver<'a, 'e, 's, E>
where
    E: DiagnosticSink<NameResolutionError<'s>>,
{
    /// Resolves the given pattern, accumulating bindings into `names`.
    ///
    /// Note that this currently cannot return `None`, although it can emit errors.
    pub fn resolve_pattern(
        &mut self,
        pattern: &cst::Pattern<'_, 's>,
        names: &mut Names<'_, '_, 's>,
    ) -> Option<&'a nst::Pattern<'a, 's>>
    where
        E: DiagnosticSink<NameResolutionError<'s>>,
    {
        Some(self.arena.alloc(match pattern {
            cst::Pattern::ProductRow(pr) => {
                nst::Pattern::ProductRow(resolve_product_row(self.arena, pr, |target| {
                    self.resolve_pattern(target, names)
                })?)
            }
            cst::Pattern::SumRow(sr) => nst::Pattern::SumRow(resolve_sum_row(sr, |target| {
                self.resolve_pattern(target, names)
            })?),
            cst::Pattern::Whole(var) => nst::Pattern::Whole(var.span_map(|var| {
                let id = self.vars.push(*var);
                if let Some(orig) = names.insert(var.value, id) {
                    self.errors.add(NameResolutionError::Duplicate {
                        name: var.value,
                        original: self.vars[orig].span(),
                        duplicate: var.span(),
                    })
                }
                id
            })),
        }))
    }

    // Resolves nested `DotAccess` terms.
    fn resolve_nested_dots(
        &mut self,
        base: &cst::Term<'_, 's>,
        dot: Span,
        field: SpanOf<RefHandle<'s, str>>,
        names: &Names<'_, '_, 's>,
    ) -> Option<DotResolution<'a, 's>>
    where
        E: DiagnosticSink<NameResolutionError<'s>>,
    {
        Some(match base {
            // (base2 . field2) . field
            cst::Term::DotAccess {
                base: base2,
                dot: dot2,
                field: field2,
            } => match self.resolve_nested_dots(base2, *dot2, *field2, names)? {
                // m . field
                DotResolution::Module(m) => {
                    match names.get_in(m, field.value).if_none(|| {
                        self.errors.add(NameResolutionError::NotFoundIn {
                            module: m,
                            name: field,
                        })
                    })? {
                        Member::Module(m2) => DotResolution::Module(m2),
                        Member::Item(i) => DotResolution::Item(m, i),
                    }
                }
                // (m.i) . field
                DotResolution::Item(m, i) => DotResolution::FieldAccess {
                    base: self.arena.alloc(nst::Term::ItemRef(base.span().of((m, i)))),
                    dot,
                    field,
                },
                // (base2n . field2n) . field
                DotResolution::FieldAccess {
                    base: base2n,
                    dot: dot2n,
                    field: field2n,
                } => DotResolution::FieldAccess {
                    base: self.arena.alloc(nst::Term::FieldAccess {
                        base: base2n,
                        dot: dot2n,
                        field: field2n,
                    }),
                    dot,
                    field,
                },
            },
            // n . field
            cst::Term::SymbolRef(n) => {
                match names
                    .get(n.value)
                    .if_none(|| self.errors.add(NameResolutionError::NotFound(*n)))?
                {
                    Name::Module(m) => DotResolution::from_member(
                        m,
                        names.get_in(m, field.value).if_none(|| {
                            self.errors.add(NameResolutionError::NotFoundIn {
                                module: m,
                                name: field,
                            })
                        })?,
                    ),
                    Name::Item(m, i) => DotResolution::FieldAccess {
                        base: self.arena.alloc(nst::Term::ItemRef(base.span().of((m, i)))),
                        dot,
                        field,
                    },
                    Name::Variable(v) => DotResolution::FieldAccess {
                        base: self.arena.alloc(nst::Term::VariableRef(base.span().of(v))),
                        dot,
                        field,
                    },
                }
            }
            // (expr) . field
            _ => DotResolution::FieldAccess {
                base: self.resolve_term(base, names)?,
                dot,
                field,
            },
        })
    }

    /// Resolves the given term.
    pub fn resolve_term(
        &mut self,
        term: &cst::Term<'_, 's>,
        names: &Names<'_, '_, 's>,
    ) -> Option<&'a nst::Term<'a, 's>>
    where
        E: DiagnosticSink<NameResolutionError<'s>>,
    {
        Some(
            self.arena.alloc(match term {
                cst::Term::Binding {
                    var,
                    eq,
                    value,
                    semi,
                    expr,
                } => {
                    let id = self.vars.push(*var);
                    let value = self.resolve_term(value, names);

                    let mut scope = names.subscope();
                    if let Some(orig) = scope.insert(var.value, id) {
                        self.errors.add(NameResolutionError::Duplicate {
                            name: var.value,
                            original: self.vars[orig].span(),
                            duplicate: var.span(),
                        })
                    }
                    let expr = self.resolve_term(expr, &mut scope);

                    nst::Term::Binding {
                        var: var.span().of(id),
                        eq: *eq,
                        value: value?,
                        semi: *semi,
                        expr: expr?,
                    }
                }
                cst::Term::Handle {
                    with,
                    handler,
                    do_,
                    expr,
                } => {
                    let handler = self.resolve_term(handler, names);
                    let expr = self.resolve_term(expr, names);
                    nst::Term::Handle {
                        with: *with,
                        handler: handler?,
                        do_: *do_,
                        expr: expr?,
                    }
                }
                cst::Term::Abstraction {
                    lbar,
                    arg,
                    rbar,
                    body,
                } => {
                    let mut scope = names.subscope();
                    let id = self.vars.push(*arg);
                    if let Some(orig) = scope.insert(arg.value, id) {
                        self.errors.add(NameResolutionError::Duplicate {
                            name: arg.value,
                            original: self.vars[orig].span(),
                            duplicate: arg.span(),
                        })
                    }
                    nst::Term::Abstraction {
                        lbar: *lbar,
                        arg: arg.span().of(id),
                        rbar: *rbar,
                        body: self.resolve_term(body, &mut scope)?,
                    }
                }
                cst::Term::Application {
                    func,
                    lpar,
                    arg,
                    rpar,
                } => {
                    let func = self.resolve_term(func, names);
                    let arg = self.resolve_term(arg, names);
                    nst::Term::Application {
                        func: func?,
                        lpar: *lpar,
                        arg: arg?,
                        rpar: *rpar,
                    }
                }
                cst::Term::ProductRow(pr) => {
                    nst::Term::ProductRow(resolve_product_row(self.arena, pr, |target| {
                        self.resolve_term(target, names)
                    })?)
                }
                cst::Term::SumRow(sr) => nst::Term::SumRow(resolve_sum_row(sr, |target| {
                    self.resolve_term(target, names)
                })?),
                t @ cst::Term::DotAccess { base, dot, field } => {
                    match self.resolve_nested_dots(base, *dot, *field, names)? {
                        DotResolution::Module(m) => {
                            self.errors
                                .add(NameResolutionError::ModuleTerm(t.span().of(m)));
                            None?
                        }
                        DotResolution::Item(m, i) => nst::Term::ItemRef(t.span().of((m, i))),
                        DotResolution::FieldAccess { base, dot, field } => {
                            nst::Term::FieldAccess { base, dot, field }
                        }
                    }
                }
                cst::Term::Match {
                    match_,
                    langle,
                    cases,
                    rangle,
                } => nst::Term::Match {
                    match_: *match_,
                    langle: *langle,
                    cases: resolve_separated(self.arena, cases, |field| {
                        let mut scope = names.subscope();
                        let pattern = self.resolve_pattern(field.label, &mut scope);
                        let target = self.resolve_term(field.target, &mut scope);
                        Some(Field {
                            label: pattern?,
                            sep: field.sep,
                            target: target?,
                        })
                    })?,
                    rangle: *rangle,
                },
                cst::Term::SymbolRef(var) => {
                    match names
                        .get(var.value)
                        .if_none(|| self.errors.add(NameResolutionError::NotFound(*var)))?
                    {
                        Name::Module(m) => {
                            self.errors
                                .add(NameResolutionError::ModuleTerm(var.span().of(m)));
                            None?
                        }
                        Name::Item(m, i) => nst::Term::ItemRef(var.span().of((m, i))),
                        Name::Variable(v) => nst::Term::VariableRef(var.span().of(v)),
                    }
                }
                cst::Term::Parenthesized { lpar, term, rpar } => nst::Term::Parenthesized {
                    lpar: *lpar,
                    term: self.resolve_term(term, names)?,
                    rpar: *rpar,
                },
            }),
        )
    }

    /// Resolves the given item.
    pub fn resolve_item(
        &mut self,
        id: ItemId,
        item: &cst::Item<'_, 's>,
        names: &BaseNames<'_, 's>,
    ) -> Option<nst::Item<'a, 's>>
    where
        E: DiagnosticSink<NameResolutionError<'s>>,
    {
        Some(match item {
            cst::Item::Term { name, eq, value } => nst::Item::Term {
                name: name.span().of(id),
                eq: *eq,
                value: self
                    .arena
                    .alloc(self.resolve_term(value, &Names::new(names))?),
            },
        })
    }

    /// Resolves the given module.
    pub fn resolve_module(
        mut self,
        this: ModuleId,
        mtree: &ModuleTree<'_, 's>,
        items: &[cst::Item<'_, 's>],
    ) -> ModuleResolution<'a, 's>
    where
        E: DiagnosticSink<NameResolutionError<'s>>,
    {
        // Collect top-level names first so they can reference each other in `letrec` fashion. We'll do
        // recursion checking later.
        let (its, inames) = items.iter().fold(
            (
                IdGen::with_capacity(items.len()),
                HashMap::with_capacity(items.len()),
            ),
            |(mut gen, mut inames), item| {
                let id = gen.push(item.name());
                match inames.entry(item.name().value) {
                    Entry::Occupied(o) => self.errors.add(NameResolutionError::Duplicate {
                        name: *o.key(),
                        original: gen[*o.get()].span(),
                        duplicate: item.name().span(),
                    }),
                    Entry::Vacant(v) => {
                        v.insert(id);
                    }
                }
                (gen, inames)
            },
        );

        let base = BaseNames::new(this, mtree, &inames);
        let res = self.arena.alloc_slice_fill_iter(
            its.iter_enumerate()
                .zip(items.iter())
                .map(|((id, _), item)| self.resolve_item(id, item, &base)),
        );
        ModuleResolution {
            items: its.into_boxed_ids(),
            vars: self.vars.into_boxed_ids(),
            item_names: inames,
            resolved_items: res,
        }
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use aiahr_core::{
        diagnostic::nameres::NameResolutionError,
        field, h,
        id::{Ids, ItemId, ModuleId, VarId},
        id_field,
        memory::{
            arena::BumpArena,
            handle::RefHandle,
            intern::{InternerByRef, SyncInterner},
        },
        nitem_term, npat_prod, npat_var, nst, nterm_abs, nterm_app, nterm_dot, nterm_item,
        nterm_local, nterm_match, nterm_prod, nterm_sum, nterm_var, nterm_with,
        span::{Span, SpanOf},
        span_of,
    };
    use aiahr_parser::{
        lexer::aiahr_lexer,
        parser::{aiahr_parser, term, to_stream},
    };
    use assert_matches::assert_matches;
    use bumpalo::Bump;
    use chumsky::Parser;

    use crate::{base::BaseNames, modules::ModuleTree, names::Names};

    use super::Resolver;

    fn parse_resolve_term<'a, 's, S>(
        arena: &'a Bump,
        interner: &'s S,
        input: &str,
    ) -> (
        Option<&'a nst::Term<'a, 's>>,
        Box<Ids<VarId, SpanOf<RefHandle<'s, str>>>>,
        Vec<NameResolutionError<'s>>,
    )
    where
        S: InternerByRef<str>,
    {
        let (tokens, eoi) = aiahr_lexer(interner).lex(input).unwrap();
        let unresolved = term(arena).parse(to_stream(tokens, eoi)).unwrap();
        let mut errors = Vec::new();

        let inames = HashMap::new();
        let mtree = ModuleTree::new();
        let base = BaseNames::new(ModuleId(0), &mtree, &inames);

        let mut resolver = Resolver::new(arena, &mut errors);
        let resolved = resolver.resolve_term(unresolved, &Names::new(&base));
        (resolved, resolver.into_vars(), errors)
    }

    fn parse_resolve_module<'a, 's, S>(
        arena: &'a Bump,
        interner: &'s S,
        input: &str,
    ) -> (
        &'a [Option<nst::Item<'a, 's>>],
        Box<Ids<ItemId, SpanOf<RefHandle<'s, str>>>>,
        Box<Ids<VarId, SpanOf<RefHandle<'s, str>>>>,
        Vec<NameResolutionError<'s>>,
    )
    where
        S: InternerByRef<str>,
    {
        let (tokens, eoi) = aiahr_lexer(interner).lex(input).unwrap();
        let unresolved = aiahr_parser(arena).parse(to_stream(tokens, eoi)).unwrap();
        let mut errors = Vec::new();

        let resolved = Resolver::new(arena, &mut errors).resolve_module(
            ModuleId(0),
            &ModuleTree::new(),
            unresolved,
        );
        (
            resolved.resolved_items,
            resolved.items,
            resolved.vars,
            errors,
        )
    }

    #[test]
    fn test_local_binding() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "x = {}; y = {}; x");
        assert_matches!(
            term,
            Some(nterm_local!(
                x,
                nterm_prod!(),
                nterm_local!(y, nterm_prod!(), nterm_var!(x1))
            )) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(vars[y].value.0, "y");
                assert_eq!(x1, x);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_local_binding_shadowing() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "x = {}; x = x; x");
        assert_matches!(term,
            Some(nterm_local!(
                x_out,
                nterm_prod!(),
                nterm_local!(x_in, nterm_var!(x1), nterm_var!(x2))
            )) => {
                assert_eq!(vars[x_out].value.0, "x");
                assert_eq!(vars[x_in].value.0, "x");
                assert_eq!(x1, x_out);
                assert_eq!(x2, x_in);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_local_binding_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) = parse_resolve_term(&arena, &interner, "x = y; z");
        assert_matches!(term, None);
        assert_matches!(
            errs[..],
            [
                NameResolutionError::NotFound(span_of!(h!("y"))),
                NameResolutionError::NotFound(span_of!(h!("z")))
            ]
        );
    }

    #[test]
    fn test_handler() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "x = {}; with x do x");
        assert_matches!(term,
            Some(nterm_local!(
                x,
                nterm_prod!(),
                nterm_with!(nterm_var!(x1), nterm_var!(x2))
            )) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(x1, x);
                assert_eq!(x2, x);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_handler_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) = parse_resolve_term(&arena, &interner, "with h do x");
        assert_matches!(term, None);
        assert_matches!(
            errs[..],
            [
                NameResolutionError::NotFound(span_of!(h!("h"))),
                NameResolutionError::NotFound(span_of!(h!("x")))
            ]
        );
    }

    #[test]
    fn test_abstraction() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "|x| |y| y(x)");
        assert_matches!(term,
            Some(nterm_abs!(
                x,
                nterm_abs!(
                    y,
                    nterm_app!(nterm_var!(y1), nterm_var!(x1))
                )
            )) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(vars[y].value.0, "y");
                assert_eq!(x1, x);
                assert_eq!(y1, y);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_abstraction_shadowing() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "|x| |x| x(x)");
        assert_matches!(term,
            Some(nterm_abs!(
                x_out,
                nterm_abs!(
                    x_in,
                    nterm_app!(nterm_var!(x1), nterm_var!(x2))
                )
            )) => {
                assert_eq!(vars[x_out].value.0, "x");
                assert_eq!(vars[x_in].value.0, "x");
                assert_eq!(x1, x_in);
                assert_eq!(x2, x_in);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_application() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "|x| x(x)");
        assert_matches!(term,
            Some(nterm_abs!(
                x,
                nterm_app!(nterm_var!(x1), nterm_var!(x2))
            )) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(x1, x);
                assert_eq!(x2, x);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_application_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) = parse_resolve_term(&arena, &interner, "f(x)");
        assert_matches!(term, None);
        assert_matches!(
            errs[..],
            [
                NameResolutionError::NotFound(span_of!(h!("f"))),
                NameResolutionError::NotFound(span_of!(h!("x")))
            ]
        );
    }

    #[test]
    fn test_product_row() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) =
            parse_resolve_term(&arena, &interner, "x = {}; {a = x, b = {x = x}}");
        assert_matches!(term,
            Some(nterm_local!(x, nterm_prod!(),
                nterm_prod!(
                id_field!("a", nterm_var!(x1)),
                id_field!(
                    "b",
                    nterm_prod!(id_field!("x", nterm_var!(x2)))
                ),
            ))) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(x1, x);
                assert_eq!(x2, x);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_product_row_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) = parse_resolve_term(&arena, &interner, "{x = y, z = x}");
        assert_matches!(term, None);
        assert_matches!(
            errs[..],
            [
                NameResolutionError::NotFound(span_of!(h!("y"))),
                NameResolutionError::NotFound(span_of!(h!("x")))
            ]
        );
    }

    #[test]
    fn test_sum_row() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "|x| <a = x>");
        assert_matches!(term,
            Some(nterm_abs!(x, nterm_sum!(id_field!("a", nterm_var!(x1))))) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(x1, x);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_sum_row_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) = parse_resolve_term(&arena, &interner, "<x = x>");
        assert_matches!(term, None);
        assert_matches!(errs[..], [NameResolutionError::NotFound(span_of!(h!("x")))]);
    }

    #[test]
    fn test_dot_access() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) = parse_resolve_term(&arena, &interner, "id = |x| x; {x = id}.x");
        assert_matches!(term,
            Some(nterm_local!(
                id,
                nterm_abs!(x, nterm_var!(x1)),
                nterm_dot!(
                    nterm_prod!(id_field!("x", nterm_var!(id1))),
                    "x"
                )
            )) => {
                assert_eq!(vars[id].value.0, "id");
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(x1, x);
                assert_eq!(id1, id);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_dot_access_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) = parse_resolve_term(&arena, &interner, "x.a");
        assert_matches!(term, None);
        assert_matches!(errs[..], [NameResolutionError::NotFound(span_of!(h!("x")))]);
    }

    #[test]
    fn test_match() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) =
            parse_resolve_term(&arena, &interner, "match <{a = x} => x, y => y>");
        assert_matches!(term,
            Some(nterm_match!(
                field!(npat_prod!(id_field!("a", npat_var!(x))), nterm_var!(x1)),
                field!(npat_var!(y), nterm_var!(y1))
            )) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(vars[y].value.0, "y");
                assert_eq!(x1, x);
                assert_eq!(y1, y);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_match_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, _, errs) =
            parse_resolve_term(&arena, &interner, "match <{a = x} => f(x), {} => z>");
        assert_matches!(term, None);
        assert_matches!(
            errs[..],
            [
                NameResolutionError::NotFound(span_of!(h!("f"))),
                NameResolutionError::NotFound(span_of!(h!("z")))
            ]
        );

        let (term, vars, errs) =
            parse_resolve_term(&arena, &interner, "match <{a = x, b = x} => x(x)>");
        assert_matches!(
            term,
            Some(nterm_match!(field!(
                npat_prod!(
                    id_field!("a", npat_var!(x)),
                    id_field!("b", npat_var!(x_again))
                ),
                nterm_app!(nterm_var!(x1), nterm_var!(x2))
            ))) => {
                assert_eq!(vars[x].value.0, "x");
                assert_eq!(vars[x_again].value.0, "x");
                assert_eq!(x1, x);
                assert_eq!(x2, x);
            }
        );
        assert_matches!(
            errs[..],
            [NameResolutionError::Duplicate {
                name: h!("x"),
                original: Span { end, ..},
                duplicate: Span { start, ..},
            }] => {
                assert!(end.byte < start.byte, "{} < {}", end.byte, start.byte);
            }
        )
    }

    #[test]
    fn test_mixed_shadowing() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (term, vars, errs) =
            parse_resolve_term(&arena, &interner, "x = {}; |x| match <x => x>");
        assert_matches!(term,
            Some(nterm_local!(x_top, nterm_prod!(), nterm_abs!(x_mid, nterm_match!(field!(npat_var!(x_bot), nterm_var!(x1)))))) => {
                assert_eq!(vars[x_top].value.0, "x");
                assert_eq!(vars[x_mid].value.0, "x");
                assert_eq!(vars[x_bot].value.0, "x");
                assert_eq!(x1, x_bot);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_top_level_letrec() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (res, items, _, errs) = parse_resolve_module(&arena, &interner, "foo = bar\nbar = foo");
        assert_matches!(
            res[..],
            [
                Some(nitem_term!(foo, nterm_item!(mbar, bar1))),
                Some(nitem_term!(bar, nterm_item!(mfoo, foo1)))
            ] => {
                assert_eq!(items[foo].value.0, "foo");
                assert_eq!(items[bar].value.0, "bar");
                assert_eq!(mbar, ModuleId(0));
                assert_eq!(mfoo, ModuleId(0));
                assert_eq!(bar1, bar);
                assert_eq!(foo1, foo);
            }
        );
        assert_matches!(errs[..], []);
    }

    #[test]
    fn test_top_level_errors() {
        let arena = Bump::new();
        let interner = SyncInterner::new(BumpArena::new());
        let (res, _, _, errs) = parse_resolve_module(&arena, &interner, "foo = x\nbar = y");
        assert_matches!(res[..], [None, None]);
        assert_matches!(
            errs[..],
            [
                NameResolutionError::NotFound(span_of!(h!("x"))),
                NameResolutionError::NotFound(span_of!(h!("y")))
            ]
        );
    }
}
